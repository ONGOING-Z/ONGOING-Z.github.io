<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>C 语言的一些基础知识 02 | ongoing's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>C 语言的一些基础知识 02</span></h1><h2 class=date>2020/10/01</h2></div><main><p>新增一些关于 C 和 C++ 的基础知识。</p><hr><ol><li><p>数组初始化符号<code>{}</code></p></li><li><p>Get array length(C)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> arr[];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(arr)<span style=color:#f92672>/</span><span style=color:#66d9ef>sizeof</span>(arr[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>// 总字节数/第一个元素字节数
</span></span></span></code></pre></div></li><li><p>define</p><p><code>#define 名字 替换文本</code></p><p>（1）符号常量通常用大写字母拼写
（2）末尾无分号</p></li><li><p>C 中常量 INT_MAX 和 INT_MIN 分别表示最大、最小整数，定义在头文件 limits.h 中。INT_MAX = 2^31-1，INT_MIN= -2^31</p></li><li><p>逻辑移位</p><p>逻辑移位 = (1) 逻辑左移 (2) 逻辑右移; 移出的空位都用 0 来补。</p></li><li><p>nullptr</p><p>其指 c++ 中的空指针常量。</p></li><li><p>c++ delete</p><p>假设 ptr 是一个指针，delete ptr 代表释放内存，只用来释放 ptr 指向的内存。</p></li><li><p>to_string()</p><p>将数值转换为字符串。</p></li><li><p>for 循环遍历字符串的一种新方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;better&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c  <span style=color:#f92672>=</span> str)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%c</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>c++ auto (since C++ 11)(谨慎使用)</p><p>可以自动推断变量类型</p><ol><li>auto变量必须在定义时进行初始化，如果不进行初始化，就不能进行变量类型的推断了。</li></ol></li><li><p>c++ pair/ make_pair</p><p>C++标准程序库中凡是“必须返回两个值”的函数， 也都会利用pair对象。</p><p><code>make_pair</code>的用法
无需写出型别， 就可以生成一个pair对象。
例： <code>std =:make_pair(42, '@');</code></p><p>而不必费力写成： <code>std =:pair&lt;int, char>(42, '@')</code></p><p>值的访问 = 两个值可以分别用pair的两个公有函数first和second访问。</p></li><li><p>map 的 count 和 find,map 和 unordered_map</p><p>使用count，返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。</p><p>使用find，返回的是被查找元素的位置，没有则返回map.end()。</p></li><li><p>string.substr()</p><p>string.substr(start, [length])</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>string s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12345&#34;</span>
</span></span><span style=display:flex><span>string sub1 <span style=color:#f92672>=</span> s.substr(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// sub1 = &#34;345&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>string sub2 <span style=color:#f92672>=</span>  s.substr(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>// sub2 = &#34;34&#34;
</span></span></span></code></pre></div></li><li><p>string to int = stoi()</p><p>stoi(str, start_position, 2) 2是进制，此例意为将2进制的str从position转换成10进制</p></li><li><p>char to int = <code>c - '0'</code></p></li><li><p>int to char = <code>i + '0'</code></p></li><li><p>异或</p><ul><li>性质 = <code>a ^ b</code>即为 a 和 b 的二进制形式每一位进行运算，最后得到的结果。每位运算逻辑：
相同为 0，不同为 1. 类似半加。</li><li>规律 =<ul><li>任何数和本身异或为<code>0</code></li><li>任何数和 0 异或为<code>本身</code></li></ul></li></ul></li><li><p>pow(), not power, 需要<code>cmath</code>头文件</p></li><li><p>自己写的头文件要用<code>""</code>引用；标准的头文件要用<code>&lt;></code>引用。</p><p>非系统头文件的查找通常开始于源文件所在的路径。</p></li><li><p>声明与定义</p><p>定义只可出现一次，声明可以出现多次。</p></li><li><p>引用</p><p><code>int&</code>, 这里的<code>&</code>不是取地址符号，叫做<code>引用符号</code>.
变量的引用就是变量的别名。相当于一个人的小名</p><ul><li><p>声明引用时必须指定代表是哪一个变量，即对它进行初始化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a <span style=color:#f92672>=</span> b; <span style=color:#75715e>// 声明 a 是 b 的引用
</span></span></span></code></pre></div><p>如果只是<code>int &amp;a</code>, 这样就是错误的。</p></li><li><p>引用和其所代表的变量共享同一内存单元，系统不为引用另外分配存储单元。</p></li><li><p>如何判断<code>&</code>是<code>引用</code>还是<code>取地址符</code>
方法 = 判断<code>&amp;a</code>这样形式前是否有<code>类型符号</code></p></li></ul></li><li><p>C++ 中的<code>.h</code>和<code>.cpp</code>文件</p><p>在 C++ 中，分别使用<code>.h</code> 和<code>.cpp</code> 来定义一个类。 <code>.h</code> 中存放类的声明，函数原型（放在类的声明中）。 <code>.cpp</code> 存放函数体。</p><p>也就是说，一个存放声明(declaration)，一个存放定义（definition)。</p></li><li><p>当数组作为函数参数进行传递时，数组就会自动退化为同类型指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>GetSize</span>(<span style=color:#66d9ef>int</span> data[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>sizeof</span>(data);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> Getsize(data); <span style=color:#75715e>// 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>vector</p><ul><li>front() = 返回第一个元素引用</li><li>back() = 返回最后一个元素引用</li><li>reverse 一个 vector = <code>reverse(res.begin(), res.end());</code></li></ul></li><li><p>maltimap</p><p><code>multimap</code> 容器保存的是有序的键/值对，但它可以保存<strong>重复</strong>的元素。</p></li><li><p>map</p><p><strong>注意</strong> = map 中的 key 是唯一的，并且不能修改，遇到重复的 key 就会插入失败</p></li></ol><hr><h3 id=c-stl>C++ STL</h3><h4 id=accumulate>accumulate</h4><p><code>accumulate</code>定义在<code>#include&lt;numeric></code>中，作用有两个，一个是累加求和，另一个是自定义类型数据的处理</p><ol><li><p>累加求和</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> accumulate(vec.begin(), vec.end(), begin_value);
</span></span></code></pre></div><p>前两个形参 = 累加元素范围; 第三个形参：累加初值</p><p>一个例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;numeric&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>50</span>};
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> va(<span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>5</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> accumulate(va.begin(), va.end(), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sum);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h4 id=unordered_set>unordered_set</h4><h5 id=定义>定义</h5><p>c++ unordered_set 定义 = 是一个集合，集合中的每一个元素都是唯一的，就算插入几个相同的元素，但是最后保留下的只有一个。</p><p>注意 = unordered_set 中数据是无序的。</p><h5 id=方法>方法</h5><ul><li><p>unordered_set =:find()</p><p>unordered_set =:find() 函数是 C++ STL 中的内置函数，用于在容器中搜索元素。它返回元素的迭代器，如果找到其他元素，则返回指向 unordered_set::end() 的迭代器。</p><p>用法：unordered_set_name.find(key)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>if</span>(s.find(xx) <span style=color:#f92672>!=</span> s.end()) xxx
</span></span></code></pre></div></li><li><p>unordered_set =:insert(element)</p><p>unordered_set =:insert(element)</p></li><li><p>set 与 unordered_set</p></li></ul><p>何时使用<code>set</code> = 需要有序的数据！</p><h4 id=unordered_map>unordered_map</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> myMap <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#34;张大&#34;</span>}, {<span style=color:#ae81ff>6</span>, <span style=color:#e6db74>&#34;李五&#34;</span>}};
</span></span><span style=display:flex><span>    myMap[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;李四&#34;</span>;
</span></span><span style=display:flex><span>    myMap.insert(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;陈二&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> myMap.begin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (iter <span style=color:#f92672>!=</span> myMap.end())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>iter;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>两个属性值 = <code>first</code> and <code>second</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>myMap.<span style=color:#a6e22e>first</span> <span style=color:#960050;background-color:#1e0010>#</span> myMap<span style=color:#f92672>-&gt;</span>first是错误的写法
</span></span><span style=display:flex><span>myMap.<span style=color:#a6e22e>second</span>
</span></span></code></pre></div><h4 id=set>set</h4><p>set 中每个值都唯一，系统可以根据元素的值自动排序。</p><ul><li><p>set.insert()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> set1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        set1.insert(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=:</span>iterator it;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (it <span style=color:#f92672>=</span> set1.begin(); it <span style=color:#f92672>!=</span> set1.end(); it<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%d &#34;</span>, <span style=color:#f92672>*</span>it);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><hr><p>&ndash;> 前篇 <a href=/2020/04/some-basic-knowledge-of-cc-/>C 语言的一些基础知识</a></p></main><script>document.addEventListener("DOMContentLoaded",function(){const e=new PhotoSwipeLightbox({gallery:".pswp-gallery",children:"a",pswpModule:PhotoSwipe});e.init()})</script>