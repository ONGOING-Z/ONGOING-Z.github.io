<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java第三部分 继承 | ongoing's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Java第三部分 继承</span></h1><h2 class=date>2020/10/12</h2></div><main><p>Java 基础知识第三部分。</p><h2 id=面向对象特征---继承性>面向对象特征 - 继承性</h2><p>继承是多态的前提。</p><p>继承解决的主要问题：<strong>共性抽取</strong>。</p><img src=java_12.png alt><p>继承关系当中的特点：</p><ol><li>子类可以拥有父类的“内容”</li><li>子类还可以拥有自己专有的内容</li></ol><img src=java_13.png alt><p>在父子类的继承关系当中，如果成员变量重名，则<em>创建子类</em>时，访问有两种方式：</p><ol><li>直接通过<strong>子类对象</strong>访问成员变量 : 等号左边是谁，就优先用谁，没有则向上找。</li><li>间接通过<strong>成员方法</strong>访问成员变量：该方法属于谁，就优先用谁，没有则向上找。</li></ol><p>区分三种变量</p><ol><li><p>局部变量：直接写局部变量名</p></li><li><p>本类的成员变量：this.成员变量名</p></li><li><p>父类成员变量：super.成员变量名</p></li></ol><p><strong>继承中成员方法访问规则</strong> :</p><p>在父子类的继承关系中欧给你，创建子类对象，访问成员方法规则是</p><p>创建的对象是谁，就优先用谁，如果没有则向上找。、</p><p>注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，不会向下找子类。</p><p>继承中方法的重写(override)/<strong>覆盖</strong> :<img src=java-review-part-3-object-oriented-inheritance/java_14.png alt></p><p>在<strong>继承关系</strong>中，方法的名称一样，参数列表也一样。</p><p>方法覆盖重写特点 :创建的是子类对象，则优先用子类方法</p><p>注意事项：</p><ol><li><p>必须保证父子类之间方法的名称相同，参数列表也相同。</p><p><code>@override</code> :写在方法前面，用来<strong>检测</strong>是不是有效的正确覆盖重写。</p><p>写上保证更加的安全。可以不写。</p></li><li><p>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围。</p></li><li><p>子类方法权限必须<strong>大于等于</strong>父类方法权限修饰符</p><p><code>public > protected > (default) > private</code></p><p>注：(default)不是关键字default, 而是什么都不写，留空。</p></li></ol><p>设计原则：对于已经投入使用的类，尽量不要修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容。</p><p>继承中构造方法访问特点</p><ol><li><p>子类构造方法中有一个默认隐含的"super()&ldquo;调用，所以一定是先调用的父类构造，后执行的子类构造。</p></li><li><p>子类构造可以通过super关键字来调用父类重载构造</p><img src=java-review-part-3-object-oriented-inheritance/java_15.png alt><img src=java-review-part-3-object-oriented-inheritance/java_16.png alt></li><li><p>super的父类构造调用，必须是子类构造方法的第一个语句。不能子类构造调用多次super构造。</p></li></ol><img src=java_17.png alt><p>super关键字的用法 - 3种</p><ol><li>在子类的成员方法中，访问父类成员变量</li><li>在子类成员方法中，访问父类成员方法。</li><li>在子类构造方法中，访问父类构造方法。</li></ol><img src=java_18.png alt><p>this关键字的用法</p><ol><li><p>在本类成员方法中，访问本类成员变量</p></li><li><p>在本类成员方法中，访问本类的另一个成员方法</p></li><li><p>在本类构造方法中，访问本类另一个构造方法。</p><p>在第三种构造中注意：this(&mldr;)调用也必须是构造方法的第一个语句。唯一一个。</p><p>super和this两种构造调用，不能同时使用，只能使用一个。</p></li></ol><p>this和super内存图解</p><img src=java_19.png alt><p>java继承的3个特点</p><ol><li>java语言是单继承的。一个类的直接父亲只能有唯一一个。
<img src=java-review-part-3-object-oriented-inheritance/java_20.png alt></li><li>java语言可以多级继承。父亲有父亲。</li><li>一个子类的直接父类唯一，但是一个父类可以有很多子类。</li></ol><h3 id=抽象>抽象</h3><img src=java_21.png alt><p>抽象方法定义与抽象类定义</p><img src=java_22.png alt><p>抽象类和抽象方法的使用：</p><ol><li>不能直接创建new抽象类对象</li><li>必须用一个子类来继承抽象父类。</li><li>子类必须<strong>覆盖重写</strong>抽象父类当中所有的抽象方法。
覆盖重写（实现）：子类去掉抽象方法的abstract关键字，补上大括号和方法体。</li><li>创建子类对象进行使用。
<img src=java_23.png alt></li></ol><h3 id=接口>接口</h3><ul><li>接口就是一种<strong>公共规范标准</strong>。</li><li>接口是多个类的公共规范，接口是一种引用数据类型。</li><li>接口<strong>最重要的内容</strong>就是：抽象方法。</li></ul><p>接口定义基本格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>接口名称</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 接口内容</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><img src=java_24.png alt><p>接口的抽象方法定义：</p><ul><li>在任何版本java中，都可以定义抽象方法</li><li>接口中的抽象方法，修饰符必须是：<code>public abstract</code>, 但是这两个关键字可以进行省略</li></ul><p>接口使用步骤：</p><ol><li><p><strong>接口不能直接使用</strong>，必须有一个“实现类”来实现该接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>实现类名称</span> <span style=color:#66d9ef>implements</span> 接口名称 {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>接口的实现类必须覆盖重写接口中的所有抽象方法。
覆盖重写（实现）：子类去掉抽象方法的abstract关键字，补上大括号和方法体。</p></li><li><p>创建实现类的对象，使用。</p></li></ol><img src=java_26.png alt><img src=java_25.png alt><p>接口的静态方法定义：</p><img src=java_27.png alt><p>接口静态方法使用 :</p><ol><li>不能通过接口实现类的对象来调用接口当中的静态方法</li><li>用法 : 通过接口名称调用静态方法</li><li>格式：接口名称.静态方法名（参数）</li></ol><p>接口的私有方法定义：</p><img src=java_28.png alt><p>接口常量定义和使用</p><img src=java_29.png alt><p>一旦使用final关键字，说明不可改变。</p><p>注意</p><ol><li>接口中的常量，可以省略<code>public static final</code>，但是不<img src=java-review-part-3-object-oriented-inheritance/java_30.png alt>写也照样是这样。</li><li>接口中的常量，必须进行赋值。</li><li>接口中常量的名称，完全使用大写字母，用下划线进行分隔。（推荐命名规则)</li></ol><p>使用接口时注意：</p><ol><li><p>接口不能有静态代码块</p></li><li><p>接口不能有构造方法（因为它是不能new的）</p></li><li><p>一个类直接父类唯一，但是一个类可以实现多个接口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyInterfaceImpl</span> <span style=color:#66d9ef>implements</span> InterfaceA, InterfaceB {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ....</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>如果实现类所实现的多个接口中，存在重复的抽象方法，只需要覆盖重写一次即可。</p></li><li><p>如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类必须是抽象类。</p></li><li><p>如果实现类实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</p></li><li><p>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。</p></li></ol><p>接口之间的多继承</p><ol><li>类与类之间是单继承的。直接父类只有一个</li><li>类与接口之间是多实现的。一个类可以实现多个接口。</li><li>接口与接口直接是多继承的</li></ol><p>注意：</p><ol><li>多个父接口中的抽象方法如果重复，没关系</li><li>多个父接口中的默认方法如果重复，子接口必须进行默认方法的覆盖重写。（default不能省去）</li></ol></main><script>document.addEventListener("DOMContentLoaded",function(){const e=new PhotoSwipeLightbox({gallery:".pswp-gallery",children:"a",pswpModule:PhotoSwipe});e.init()})</script>