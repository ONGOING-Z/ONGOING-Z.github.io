<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 第三部分 继承 | ongoing's blog</title><link rel=dns-prefetch href=https://image.ongoingblog.org><link rel=preconnect href=https://image.ongoingblog.org crossorigin><link rel=preload href=/css/style.css as=style><link rel=preload href=/css/fonts.css as=style><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/chroma.css><link rel=prefetch href=/js/katex/katex.min.css as=style><link rel=prefetch href=/js/katex/katex.min.js as=script><link rel=prefetch href=/css/loading.css as=style><script>function loadKaTeX(){const e=document.body?document.body.textContent:"",t=e.match(/\$\$|\\\[|\\\(|\$[^$\n]+\$/)||document.querySelector('script[type="math/tex"]');if(t){const e=document.createElement("link");e.rel="stylesheet",e.href="/js/katex/katex.min.css",e.onerror=function(){console.warn("KaTeX CSS 加载失败，尝试使用备用路径"),e.href="https://ongoingblog.org/js/katex/katex.min.css"},document.querySelector(`link[href="${e.href}"]`)||document.head.appendChild(e);const t=document.createElement("link");t.rel="stylesheet",t.href="/css/loading.css",t.onerror=function(){console.warn("loading.css 加载失败，尝试使用备用路径"),t.href="https://ongoingblog.org/css/loading.css"},document.querySelector(`link[href="${t.href}"]`)||document.head.appendChild(t);const n=document.createElement("script");n.src="/js/katex/katex.min.js",n.onerror=function(){console.warn("KaTeX JS 加载失败，尝试使用备用路径"),n.src="https://ongoingblog.org/js/katex/katex.min.js"},n.async=!0,n.onload=function(){const e=document.createElement("script");e.src="/js/katex/contrib/auto-render.min.js",e.async=!0,e.onload=function(){typeof renderMathInElement=="function"&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})},document.head.appendChild(e)},document.head.appendChild(n)}}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",function(){setTimeout(loadKaTeX,100)}):setTimeout(loadKaTeX,100)</script><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll("img.lazy-image[data-src]");function s(e){const t=e.getBoundingClientRect();return t.top>=0&&t.left>=0&&t.bottom<=(window.innerHeight||document.documentElement.clientHeight)+100&&t.right<=(window.innerWidth||document.documentElement.clientWidth)}function t(e){const t=e.getAttribute("data-src");if(t){const n=e.closest(".image-loading-container");return n&&n.classList.add("loading"),e.src=t,e.removeAttribute("data-src"),e.classList.remove("lazy-image"),e.addEventListener("load",function(){n&&n.classList.remove("loading")}),e.addEventListener("error",function(){n&&n.classList.remove("loading")}),!0}return!1}n.forEach(e=>{s(e)&&t(e)});const e=document.querySelectorAll("img.lazy-image[data-src]");if(e.length>0&&"IntersectionObserver"in window){const n=new IntersectionObserver((e,n)=>{e.forEach(e=>{if(e.isIntersecting){const s=e.target;t(s)&&n.unobserve(s)}})},{rootMargin:"100px"});e.forEach(e=>{n.observe(e)})}else e.length>0&&e.forEach(e=>{t(e)});document.querySelectorAll("main img").forEach(e=>{if(e.parentNode.tagName==="A"){e.parentNode.target="_blank";return}const t=document.createElement("a");t.href=e.src||e.getAttribute("data-src")||"",t.target="_blank",t.style.cursor="zoom-in",e.parentNode.insertBefore(t,e),t.appendChild(e)})})</script><link rel=prefetch href=/pagefind/pagefind-ui.css as=style><link rel=prefetch href=/pagefind/pagefind-ui.js as=script></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li><li><a href=/tags/>标签</a></li><li><a href=/#search onclick="return toggleSearch(),!1">搜索</a></li></ul><hr></nav><div id=search-container style=display:none><div id=search></div></div><script>let pagefindInitialized=!1,pagefindScriptLoaded=!1,pagefindCssLoaded=!1;function loadPagefind(){if(pagefindScriptLoaded)return;if(pagefindScriptLoaded=!0,!pagefindCssLoaded){const e=document.createElement("link");e.rel="stylesheet",e.href="/pagefind/pagefind-ui.css",e.onerror=function(){console.warn("Pagefind CSS 加载失败，尝试使用备用路径"),e.href="https://ongoingblog.org/pagefind/pagefind-ui.css"},document.head.appendChild(e),pagefindCssLoaded=!0}const e=document.createElement("script");e.src="/pagefind/pagefind-ui.js",e.async=!0,e.onload=function(){typeof PagefindUI!="undefined"&&initializePagefind()},e.onerror=function(){console.error("Pagefind JS 加载失败，尝试使用备用路径"),e.src="https://ongoingblog.org/pagefind/pagefind-ui.js"},document.head.appendChild(e)}function initializePagefind(){if(!pagefindInitialized)try{new PagefindUI({element:"#search",showSubResults:!0,showImages:!1}),pagefindInitialized=!0}catch(e){console.error("Pagefind 初始化失败:",e)}}function toggleSearch(){const e=document.getElementById("search-container");e.style.display==="none"||e.style.display===""?(e.style.display="block",pagefindScriptLoaded?!pagefindInitialized&&typeof PagefindUI!="undefined"&&initializePagefind():loadPagefind(),setTimeout(()=>{const t=e.querySelector("input");t&&t.focus()},100)):e.style.display="none"}</script><div class=article-meta><h1><span class=title>Java 第三部分 继承</span></h1><h2 class=date>2020/10/12</h2></div><main data-pagefind-body><div class=toc-container><h2 class=toc-title>文章目录</h2><div class=toc-content><nav id=TableOfContents><ul><li><a href=#面向对象特征---继承性>面向对象特征 - 继承性</a><ul><li><a href=#抽象>抽象</a></li><li><a href=#接口>接口</a></li></ul></li></ul></nav></div></div><style>.toc-container{border-left:3px solid #4a86e8;padding:1.2rem 1.8rem;margin:2.5rem 0;background:#f8fbfe;border-radius:0 8px 8px 0;box-shadow:0 2px 10px rgba(0,0,0,5%)}.toc-title{font-size:1.4rem;margin-top:0;margin-bottom:1rem;color:#2c5282;padding-bottom:.5rem;border-bottom:1px solid #e2e8f0}.toc-content ul{list-style:none;padding-left:1.2rem;margin:0}.toc-content li{margin:.7rem 0;line-height:1.1;position:relative}.toc-content a{color:#3182ce;text-decoration:none;transition:all .3s ease;display:block;padding:.3rem .5rem;border-radius:4px}.toc-content a:hover{color:#020202;background:#ebf4ff;padding-left:.8rem}.toc-warning{padding:1.2rem;background:#fffaf0;border:1px solid #feebc8;border-radius:6px;color:#dd6b20;margin:2rem 0}.toc-warning p{margin:.5rem 0}.toc-highlight{animation:highlight-fade 2s ease;background-color:rgba(255,230,0,.3)}@keyframes highlight-fade{0%{background-color:rgba(255,230,0,.8)}100%{background-color:initial}}.toc-debug{font-size:.9rem;color:#4a5568}.toc-debug h4{margin-top:0;color:#2b6cb0}</style><p>Java 基础知识第三部分。</p><h2 id=面向对象特征---继承性>面向对象特征 - 继承性</h2><p>继承是多态的前提。</p><p>继承解决的主要问题：<strong>共性抽取</strong>。</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_12.png class=image-loading-container data-pswp-width=1107 data-pswp-height=657 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_12.png?format=webp&amp;quality=85" alt class=lazy-image width=1107 height=657 style=max-width:100%;height:auto></a></figure><p>继承关系当中的特点：</p><ol><li>子类可以拥有父类的“内容”</li><li>子类还可以拥有自己专有的内容</li></ol><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_13.png class=image-loading-container data-pswp-width=802 data-pswp-height=385 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_13.png?format=webp&amp;quality=85" alt class=lazy-image width=802 height=385 style=max-width:100%;height:auto></a></figure><p>在父子类的继承关系当中，如果成员变量重名，则<em>创建子类</em>时，访问有两种方式：</p><ol><li>直接通过<strong>子类对象</strong>访问成员变量 : 等号左边是谁，就优先用谁，没有则向上找。</li><li>间接通过<strong>成员方法</strong>访问成员变量：该方法属于谁，就优先用谁，没有则向上找。</li></ol><p>区分三种变量</p><ol><li><p>局部变量：直接写局部变量名</p></li><li><p>本类的成员变量：this.成员变量名</p></li><li><p>父类成员变量：super.成员变量名</p></li></ol><p><strong>继承中成员方法访问规则</strong> :</p><p>在父子类的继承关系中欧给你，创建子类对象，访问成员方法规则是</p><p>创建的对象是谁，就优先用谁，如果没有则向上找。、</p><p>注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，不会向下找子类。</p><p>继承中方法的重写 (override)/<strong>覆盖</strong> :<figure class=pswp-gallery style=display:inline-block;margin:0><a href=java-review-part-3-object-oriented-inheritance/java_14.png class=image-loading-container data-pswp-width=800 data-pswp-height=600 target=_blank><img src=#ZgotmplZ data-src=java-review-part-3-object-oriented-inheritance/java_14.png alt class=lazy-image style=max-width:100%;height:auto></a></figure></p><p>在<strong>继承关系</strong>中，方法的名称一样，参数列表也一样。</p><p>方法覆盖重写特点 :创建的是子类对象，则优先用子类方法</p><p>注意事项：</p><ol><li><p>必须保证父子类之间方法的名称相同，参数列表也相同。</p><p><code>@override</code> :写在方法前面，用来<strong>检测</strong>是不是有效的正确覆盖重写。</p><p>写上保证更加的安全。可以不写。</p></li><li><p>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围。</p></li><li><p>子类方法权限必须<strong>大于等于</strong>父类方法权限修饰符</p><p><code>public > protected > (default) > private</code></p><p>注：(default) 不是关键字 default, 而是什么都不写，留空。</p></li></ol><p>设计原则：对于已经投入使用的类，尽量不要修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容。</p><p>继承中构造方法访问特点</p><ol><li><p>子类构造方法中有一个默认隐含的"super()&ldquo;调用，所以一定是先调用的父类构造，后执行的子类构造。</p></li><li><p>子类构造可以通过 super 关键字来调用父类重载构造</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=java-review-part-3-object-oriented-inheritance/java_15.png class=image-loading-container data-pswp-width=800 data-pswp-height=600 target=_blank><img src=#ZgotmplZ data-src=java-review-part-3-object-oriented-inheritance/java_15.png alt class=lazy-image style=max-width:100%;height:auto></a></figure><figure class=pswp-gallery style=display:inline-block;margin:0><a href=java-review-part-3-object-oriented-inheritance/java_16.png class=image-loading-container data-pswp-width=800 data-pswp-height=600 target=_blank><img src=#ZgotmplZ data-src=java-review-part-3-object-oriented-inheritance/java_16.png alt class=lazy-image style=max-width:100%;height:auto></a></figure></li><li><p>super 的父类构造调用，必须是子类构造方法的第一个语句。不能子类构造调用多次 super 构造。</p></li></ol><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_17.png class=image-loading-container data-pswp-width=1244 data-pswp-height=62 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_17.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1244 height=62 style=max-width:100%;height:auto></a></figure><p>super 关键字的用法 - 3 种</p><ol><li>在子类的成员方法中，访问父类成员变量</li><li>在子类成员方法中，访问父类成员方法。</li><li>在子类构造方法中，访问父类构造方法。</li></ol><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_18.png class=image-loading-container data-pswp-width=676 data-pswp-height=38 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_18.png?format=webp&amp;quality=85" alt class=lazy-image width=676 height=38 style=max-width:100%;height:auto></a></figure><p>this 关键字的用法</p><ol><li><p>在本类成员方法中，访问本类成员变量</p></li><li><p>在本类成员方法中，访问本类的另一个成员方法</p></li><li><p>在本类构造方法中，访问本类另一个构造方法。</p><p>在第三种构造中注意：this(&mldr;) 调用也必须是构造方法的第一个语句。唯一一个。</p><p>super 和 this 两种构造调用，不能同时使用，只能使用一个。</p></li></ol><p>this 和 super 内存图解</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_19.png class=image-loading-container data-pswp-width=1894 data-pswp-height=760 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_19.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1894 height=760 style=max-width:100%;height:auto></a></figure><p>java 继承的 3 个特点</p><ol><li>java 语言是单继承的。一个类的直接父亲只能有唯一一个。<figure class=pswp-gallery style=display:inline-block;margin:0><a href=java-review-part-3-object-oriented-inheritance/java_20.png class=image-loading-container data-pswp-width=800 data-pswp-height=600 target=_blank><img src=#ZgotmplZ data-src=java-review-part-3-object-oriented-inheritance/java_20.png alt class=lazy-image style=max-width:100%;height:auto></a></figure></li><li>java 语言可以多级继承。父亲有父亲。</li><li>一个子类的直接父类唯一，但是一个父类可以有很多子类。</li></ol><h3 id=抽象>抽象</h3><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_21.png class=image-loading-container data-pswp-width=1695 data-pswp-height=700 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_21.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1695 height=700 style=max-width:100%;height:auto></a></figure><p>抽象方法定义与抽象类定义</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_22.png class=image-loading-container data-pswp-width=913 data-pswp-height=446 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_22.png?format=webp&amp;quality=85" alt class=lazy-image width=913 height=446 style=max-width:100%;height:auto></a></figure><p>抽象类和抽象方法的使用：</p><ol><li>不能直接创建 new 抽象类对象</li><li>必须用一个子类来继承抽象父类。</li><li>子类必须<strong>覆盖重写</strong>抽象父类当中所有的抽象方法。
覆盖重写（实现）：子类去掉抽象方法的 abstract 关键字，补上大括号和方法体。</li><li>创建子类对象进行使用。<figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_23.png class=image-loading-container data-pswp-width=1149 data-pswp-height=626 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_23.png?format=webp&amp;quality=85" alt class=lazy-image width=1149 height=626 style=max-width:100%;height:auto></a></figure></li></ol><h3 id=接口>接口</h3><ul><li>接口就是一种<strong>公共规范标准</strong>。</li><li>接口是多个类的公共规范，接口是一种引用数据类型。</li><li>接口<strong>最重要的内容</strong>就是：抽象方法。</li></ul><p>接口定义基本格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>接口名称</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 接口内容</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_24.png class=image-loading-container data-pswp-width=591 data-pswp-height=281 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_24.png?format=webp&amp;quality=85" alt class=lazy-image width=591 height=281 style=max-width:100%;height:auto></a></figure><p>接口的抽象方法定义：</p><ul><li>在任何版本 java 中，都可以定义抽象方法</li><li>接口中的抽象方法，修饰符必须是：<code>public abstract</code>, 但是这两个关键字可以进行省略</li></ul><p>接口使用步骤：</p><ol><li><p><strong>接口不能直接使用</strong>，必须有一个“实现类”来实现该接口。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>实现类名称</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>接口名称</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>接口的实现类必须覆盖重写接口中的所有抽象方法。
覆盖重写（实现）：子类去掉抽象方法的 abstract 关键字，补上大括号和方法体。</p></li><li><p>创建实现类的对象，使用。</p></li></ol><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_26.png class=image-loading-container data-pswp-width=958 data-pswp-height=64 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_26.png?format=webp&amp;quality=85" alt class=lazy-image width=958 height=64 style=max-width:100%;height:auto></a></figure><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_25.png class=image-loading-container data-pswp-width=597 data-pswp-height=242 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_25.png?format=webp&amp;quality=85" alt class=lazy-image width=597 height=242 style=max-width:100%;height:auto></a></figure><p>接口的静态方法定义：</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_27.png class=image-loading-container data-pswp-width=768 data-pswp-height=220 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_27.png?format=webp&amp;quality=85" alt class=lazy-image width=768 height=220 style=max-width:100%;height:auto></a></figure><p>接口静态方法使用 :</p><ol><li>不能通过接口实现类的对象来调用接口当中的静态方法</li><li>用法 : 通过接口名称调用静态方法</li><li>格式：接口名称。静态方法名（参数）</li></ol><p>接口的私有方法定义：</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_28.png class=image-loading-container data-pswp-width=830 data-pswp-height=516 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_28.png?format=webp&amp;quality=85" alt class=lazy-image width=830 height=516 style=max-width:100%;height:auto></a></figure><p>接口常量定义和使用</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_29.png class=image-loading-container data-pswp-width=1026 data-pswp-height=132 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-12-Java-review-part-3-object-oriented-Inheritance/java_29.png?format=webp&amp;quality=85" alt class=lazy-image width=1026 height=132 style=max-width:100%;height:auto></a></figure><p>一旦使用 final 关键字，说明不可改变。</p><p>注意</p><ol><li>接口中的常量，可以省略<code>public static final</code>，但是不<figure class=pswp-gallery style=display:inline-block;margin:0><a href=java-review-part-3-object-oriented-inheritance/java_30.png class=image-loading-container data-pswp-width=800 data-pswp-height=600 target=_blank><img src=#ZgotmplZ data-src=java-review-part-3-object-oriented-inheritance/java_30.png alt class=lazy-image style=max-width:100%;height:auto></a></figure>写也照样是这样。</li><li>接口中的常量，必须进行赋值。</li><li>接口中常量的名称，完全使用大写字母，用下划线进行分隔。（推荐命名规则)</li></ol><p>使用接口时注意：</p><ol><li><p>接口不能有静态代码块</p></li><li><p>接口不能有构造方法（因为它是不能 new 的）</p></li><li><p>一个类直接父类唯一，但是一个类可以实现多个接口</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyInterfaceImpl</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>InterfaceA</span><span class=p>,</span><span class=w> </span><span class=n>InterfaceB</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ....</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>如果实现类所实现的多个接口中，存在重复的抽象方法，只需要覆盖重写一次即可。</p></li><li><p>如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类必须是抽象类。</p></li><li><p>如果实现类实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</p></li><li><p>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。</p></li></ol><p>接口之间的多继承</p><ol><li>类与类之间是单继承的。直接父类只有一个</li><li>类与接口之间是多实现的。一个类可以实现多个接口。</li><li>接口与接口直接是多继承的</li></ol><p>注意：</p><ol><li>多个父接口中的抽象方法如果重复，没关系</li><li>多个父接口中的默认方法如果重复，子接口必须进行默认方法的覆盖重写。（default 不能省去）</li></ol></main><footer><hr>&copy; <a href=https://ongoingblog.org/ target=_self>ONGOING-Z</a> 2020 -- 2026</footer></body></html>