<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 第二部分 封装 | ongoing's blog</title><link rel=dns-prefetch href=https://image.ongoingblog.org><link rel=preconnect href=https://image.ongoingblog.org crossorigin><link rel=preload href=/css/style.css as=style><link rel=preload href=/css/fonts.css as=style><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/chroma.css><link rel=prefetch href=/js/katex/katex.min.css as=style><link rel=prefetch href=/js/katex/katex.min.js as=script><link rel=prefetch href=/css/loading.css as=style><script>function loadKaTeX(){const e=document.body?document.body.textContent:"",t=e.match(/\$\$|\\\[|\\\(|\$[^$\n]+\$/)||document.querySelector('script[type="math/tex"]');if(t){const e=document.createElement("link");e.rel="stylesheet",e.href="/js/katex/katex.min.css",e.onerror=function(){console.warn("KaTeX CSS 加载失败，尝试使用备用路径"),e.href="https://ongoingblog.org/js/katex/katex.min.css"},document.querySelector(`link[href="${e.href}"]`)||document.head.appendChild(e);const t=document.createElement("link");t.rel="stylesheet",t.href="/css/loading.css",t.onerror=function(){console.warn("loading.css 加载失败，尝试使用备用路径"),t.href="https://ongoingblog.org/css/loading.css"},document.querySelector(`link[href="${t.href}"]`)||document.head.appendChild(t);const n=document.createElement("script");n.src="/js/katex/katex.min.js",n.onerror=function(){console.warn("KaTeX JS 加载失败，尝试使用备用路径"),n.src="https://ongoingblog.org/js/katex/katex.min.js"},n.async=!0,n.onload=function(){const e=document.createElement("script");e.src="/js/katex/contrib/auto-render.min.js",e.async=!0,e.onload=function(){typeof renderMathInElement=="function"&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})},document.head.appendChild(e)},document.head.appendChild(n)}}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",function(){setTimeout(loadKaTeX,100)}):setTimeout(loadKaTeX,100)</script><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll("img.lazy-image[data-src]");function s(e){const t=e.getBoundingClientRect();return t.top>=0&&t.left>=0&&t.bottom<=(window.innerHeight||document.documentElement.clientHeight)+100&&t.right<=(window.innerWidth||document.documentElement.clientWidth)}function t(e){const t=e.getAttribute("data-src");if(t){const n=e.closest(".image-loading-container");return n&&n.classList.add("loading"),e.src=t,e.removeAttribute("data-src"),e.classList.remove("lazy-image"),e.addEventListener("load",function(){n&&n.classList.remove("loading")}),e.addEventListener("error",function(){n&&n.classList.remove("loading")}),!0}return!1}n.forEach(e=>{s(e)&&t(e)});const e=document.querySelectorAll("img.lazy-image[data-src]");if(e.length>0&&"IntersectionObserver"in window){const n=new IntersectionObserver((e,n)=>{e.forEach(e=>{if(e.isIntersecting){const s=e.target;t(s)&&n.unobserve(s)}})},{rootMargin:"100px"});e.forEach(e=>{n.observe(e)})}else e.length>0&&e.forEach(e=>{t(e)});document.querySelectorAll("main img").forEach(e=>{if(e.parentNode.tagName==="A"){e.parentNode.target="_blank";return}const t=document.createElement("a");t.href=e.src||e.getAttribute("data-src")||"",t.target="_blank",t.style.cursor="zoom-in",e.parentNode.insertBefore(t,e),t.appendChild(e)})})</script><link rel=prefetch href=/pagefind/pagefind-ui.css as=style><link rel=prefetch href=/pagefind/pagefind-ui.js as=script></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li><li><a href=/tags/>标签</a></li><li><a href=/#search onclick="return toggleSearch(),!1">搜索</a></li></ul><hr></nav><div id=search-container style=display:none><div id=search></div></div><script>let pagefindInitialized=!1,pagefindScriptLoaded=!1,pagefindCssLoaded=!1;function loadPagefind(){if(pagefindScriptLoaded)return;if(pagefindScriptLoaded=!0,!pagefindCssLoaded){const e=document.createElement("link");e.rel="stylesheet",e.href="/pagefind/pagefind-ui.css",e.onerror=function(){console.warn("Pagefind CSS 加载失败，尝试使用备用路径"),e.href="https://ongoingblog.org/pagefind/pagefind-ui.css"},document.head.appendChild(e),pagefindCssLoaded=!0}const e=document.createElement("script");e.src="/pagefind/pagefind-ui.js",e.async=!0,e.onload=function(){typeof PagefindUI!="undefined"&&initializePagefind()},e.onerror=function(){console.error("Pagefind JS 加载失败，尝试使用备用路径"),e.src="https://ongoingblog.org/pagefind/pagefind-ui.js"},document.head.appendChild(e)}function initializePagefind(){if(!pagefindInitialized)try{new PagefindUI({element:"#search",showSubResults:!0,showImages:!1}),pagefindInitialized=!0}catch(e){console.error("Pagefind 初始化失败:",e)}}function toggleSearch(){const e=document.getElementById("search-container");e.style.display==="none"||e.style.display===""?(e.style.display="block",pagefindScriptLoaded?!pagefindInitialized&&typeof PagefindUI!="undefined"&&initializePagefind():loadPagefind(),setTimeout(()=>{const t=e.querySelector("input");t&&t.focus()},100)):e.style.display="none"}</script><div class=article-meta><h1><span class=title>Java 第二部分 封装</span></h1><h2 class=date>2020/10/10</h2></div><main data-pagefind-body><p><div class=toc-container><h2 class=toc-title>文章目录</h2><div class=toc-content><nav id=TableOfContents><ul><li><a href=#面向对象>面向对象</a><ul><li><a href=#类的定义>类的定义</a></li></ul></li><li><a href=#面向对象---封装性>面向对象 - 封装性</a><ul><li><a href=#api-文档的查看>API 文档的查看</a></li></ul></li></ul></nav></div></div><style>.toc-container{border-left:3px solid #4a86e8;padding:1.2rem 1.8rem;margin:2.5rem 0;background:#f8fbfe;border-radius:0 8px 8px 0;box-shadow:0 2px 10px rgba(0,0,0,5%)}.toc-title{font-size:1.4rem;margin-top:0;margin-bottom:1rem;color:#2c5282;padding-bottom:.5rem;border-bottom:1px solid #e2e8f0}.toc-content ul{list-style:none;padding-left:1.2rem;margin:0}.toc-content li{margin:.7rem 0;line-height:1.1;position:relative}.toc-content a{color:#3182ce;text-decoration:none;transition:all .3s ease;display:block;padding:.3rem .5rem;border-radius:4px}.toc-content a:hover{color:#020202;background:#ebf4ff;padding-left:.8rem}.toc-warning{padding:1.2rem;background:#fffaf0;border:1px solid #feebc8;border-radius:6px;color:#dd6b20;margin:2rem 0}.toc-warning p{margin:.5rem 0}.toc-highlight{animation:highlight-fade 2s ease;background-color:rgba(255,230,0,.3)}@keyframes highlight-fade{0%{background-color:rgba(255,230,0,.8)}100%{background-color:initial}}.toc-debug{font-size:.9rem;color:#4a5568}.toc-debug h4{margin-top:0;color:#2b6cb0}</style>Java 基础知识第二部分。</p><h2 id=面向对象>面向对象</h2><ul><li>面向过程：强调步骤</li><li>面向对象：强调对象<ul><li>特征：封装、继承、多态</li></ul></li><li>类：一组相关属性和行为的集合。<ul><li>属性：状态信息</li><li>行为：可以做什么</li></ul></li><li>类和对象的关系<ul><li>类是对一类事物的描述，是<strong>抽象的</strong></li><li>对象是一类事物的实例，是<strong>具体的</strong></li><li>类是对象的模板，对象是类的实体。</li></ul></li></ul><h3 id=类的定义>类的定义</h3><ul><li>成员变量（属性）<ul><li>直接定义在类当中，<strong>在方法外边</strong>。</li></ul></li><li>成员方法（行为)<ul><li>无<code>static</code>关键字</li></ul></li></ul><p>一个类不能直接使用，需要根据类创建一个对象，才能使用。</p><p>步骤：</p><ol><li>导包：指出需要什么类，在什么位置。
<code>import 包名称.类名称</code>
对于和当前类属于同一个包的情况，可以省略导包语句。</li><li>创建：<code>类名称 对象名 = new 类名称();</code></li><li>使用<ol><li>使用成员变量：<code>对象名.成员变量名</code></li><li>使用成员方法：<code>对象名.成员方法名(参数)</code></li></ol></li></ol><p>一个对象的内存图<figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_7.png class=image-loading-container data-pswp-width=1873 data-pswp-height=751 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_7.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1873 height=751 style=max-width:100%;height:auto></a></figure></p><ul><li>方法的进栈和出栈</li><li>堆中<code>成员方法</code>保存的是一个地址值</li><li>方法要执行，一定要进栈，执行完毕就出栈</li><li>new 之后有默认值</li><li>对象的名称也叫做对象的引用名</li></ul><p>使用对象类型作为方法的参数：当一个对象作为方法的参数，传递到方法当中时，实际上传递进去的是对象的<strong>地址值</strong>。</p><p>使用对象作为方法的返回值：返回值其实就是对象的<strong>地址值</strong>。</p><p>成员变量与局部变量的区别：</p><ol><li>定义位置不一样（重要）<ul><li>成员变量：在方法外部，直接写在类中</li><li>局部变量：在方法内部</li></ul></li><li>作用范围不一样（重要）<ul><li>成员变量：整个类可以通用</li><li>局部变量：只有方法中可以使用，出了方法不能使用。</li></ul></li><li>默认值不一样<ul><li>成员变量：若没有赋值，会有默认值，规则和数组一样</li><li>局部变量：没有默认值，如果要想使用，必须手动进行赋值。</li></ul></li><li>内存位置不一样（了解）<ul><li>成员变量：位于堆内存</li><li>局部变量：位于栈内存</li></ul></li><li>生命周期不一样<ul><li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失。</li><li>局部变量：随着方法进栈而诞生，随着方法出栈而消失。</li></ul></li></ol><p>方法的参数也是局部变量，在调用的时候必然会被赋值。</p><h2 id=面向对象---封装性>面向对象 - 封装性</h2><ol><li><p><strong>封装在 java 中体现</strong></p><ul><li>方法是一种封装</li><li>关键字<code>private</code>也是一种封装
使用 private 将需要保护的成员变量进行修饰。在本类中可以随意访问，但是超出本类范围之外不能<strong>直接</strong>访问。
间接访问 private 成员变量：设置一对 getter/setter 方法<ul><li>setter 方法：有参数，无返回值。方法名称必须是<code>set</code>+首字母变大写 (setXxx)</li><li>getter 方法：无参数，有返回值。方法名称必须是<code>get</code>+首字母变大写 (getXxx)。</li><li>注意：对于基本数据类型中的<code>boolean</code>型，Getter 方法一定要写成<code>isXxx</code>形式，setXxx 规则不变。</li></ul></li></ul><p>封装：将一些细节信息隐藏起来，对于外界不可见。</p></li><li><p><code>this</code>关键字</p><p>作用：在重名下起到区分的效果。</p><p>当方法的局部变量和类的成员变量重名时，根据“就近原则”，优先使用局部变量。</p><p>如果需要访问本类中的成员变量，需要使用这种格式：<code>this.成员变量名</code></p><p><strong>通过谁调用的方法，谁就是 this.</strong></p></li><li><p>构造方法</p><p>专门用来创建对象的方法。（使用构造方法创造对象可以更具体）</p><p>格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=nf>类名称</span><span class=w> </span><span class=p>(</span><span class=n>参数</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>方法体</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>注意事项：</p><ul><li>构造方法名称必须和所在类名称完全一样</li><li>构造方法不需要写返回值类型，void 也不需要</li><li>构造方法不能产生返回值。</li><li>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数且方法体什么都不做。<code>public Student() {}</code></li><li>一旦编写了至少一个构造方法，那么编译器将不再赠送。</li><li>构造方法也是可以进行重载的。</li></ul><p>new 对象就是在调用构造方法。默认调用无参构造器，如果类中定义了带参数的构造器，则不会调用无参了。</p></li><li><p><strong>标准的类</strong>(Java Bean)</p><ul><li>所有成员变量都要使用 private 关键字修饰</li><li>为每一个成员变量编写一对 Getter/Setter 方法</li><li>编写一个无参数构造方法</li><li>编写一个全参数构造方法</li></ul><p>在 IDEA 中可以自动生成下面 3 项！！！菜单<code>Code -> Generate</code></p></li></ol><h3 id=api-文档的查看>API 文档的查看</h3><ol><li>包路径</li><li>构造方法</li><li>方法摘要</li></ol><h4 id=scanner-类>Scanner 类</h4><ul><li><p>引用类型一般使用步骤</p><ol><li>导包：<code>import 包路径.类名称;</code><ul><li>如果需要使用的目标类，和当前类位于同一个包下，则可以省略包不写。</li><li>只有<code>java.lang</code>包下的内容需要导包，其他的包需要 import 语句。</li></ul></li><li>创建： <code>类名称 对象名 = new 类名称();</code></li><li>使用：对象名。成员方法 ();</li></ol><p><code>System.in</code>代表从键盘输入。</p><p>其实键盘输入的都是字符串。</p></li></ul><h4 id=匿名对象>匿名对象</h4><p>正常的创建对象格式：<code>类名称 对象名 = new 类名称();</code></p><p>匿名对象创建格式：<code>new 类名称()</code></p><p>注意：匿名对象只能使用唯一的一次，下次只能创建新的匿名对象。</p><p>建议：如果确定有一个对象只需要使用一次，就可以使用匿名对象。</p><h4 id=random-类>Random 类</h4><p>生成随机数字。</p><h4 id=对象数组>对象数组</h4><p>数组可以存储任何数据类型</p><h4 id=arraylist-集合>ArrayList 集合</h4><p>其长度可以随意改变。</p><p>对于 ArrayList 来说，有一个尖括号<code>&lt;E></code>代表泛型。</p><p>泛型：参数化类型。暂时不指定具体的类型，用一个占位符来代替。</p><p>泛型：装在集合中的所有元素，全都是统一的什么类型。</p><p>注意：<strong>泛型只能是引用类型</strong>，不能是基本类型。也就是说集合里面保存的都是地址，但是基本类型数据没有地址。</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_8.png class=image-loading-container data-pswp-width=920 data-pswp-height=339 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_8.png?format=webp&amp;quality=85" alt class=lazy-image width=920 height=339 style=max-width:100%;height:auto></a></figure><figure class=pswp-gallery style=display:inline-block;margin:0><a href=home/fifth/.config/Typora/typora-user-images/image-20201007182105425.png class=image-loading-container data-pswp-width=800 data-pswp-height=600 target=_blank><img src=#ZgotmplZ data-src=home/fifth/.config/Typora/typora-user-images/image-20201007182105425.png alt class=lazy-image style=max-width:100%;height:auto></a></figure><p><code>ArrayList&lt;String> list = new ArrayList&lt;>();</code></p><p>注意右侧的尖括号也是要写的。</p><p>注意：对于 ArrayList 集合，直接打印得到的不是地址值，而是内容。如果内容为空，则得到的是空的中括号[].</p><p>常用方法：</p><ul><li>添加数据方法：<code>public boolean add(E e)</code></li><li>从集合中获取元素：<code>public E get(int index)</code></li><li>从集合中删除元素：<code>public E remove(int index)</code></li><li>获取集合长度：<code>public int size()</code></li></ul><h4 id=string>String</h4><ul><li>程序当中所有的双引号字符串，都是<code>String</code>类的对象（就算没有 new, 也照样是)</li></ul><p>字符串的特点：</p><ol><li>字符串的内容永不可变。(重要)</li><li>因为字符串不可改变，所以字符串是可以共享使用的。</li><li>字符串效果上相当于是 char[]字符数组，但是底层原理是 byte[]字节数组。</li></ol><p>创建字符串的常见 3+1 种方式：</p><ul><li>3 种构造方法<ul><li><code>public String()</code>: 创建一个空白字符串</li><li><code>public String(char[] array)</code>: 根据字符数组内容创建字符串。</li><li><code>public String(byte[] array)</code>：根据字节数组的内容，创建对应字符串。</li></ul></li><li>1 种直接创建：<code>String str = "Helo";</code></li></ul><p>字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。<strong>new</strong>的不在池中。</p><p><code>new String("hello")</code> 这种方式是将字符串存储在了普通的内存堆中，而非常量池。
如果需要加入常量池，可以显示调用<code>java.lang.String#intern</code>方法。</p><p>注意字符串常量池也是位于堆中。其中的元信息位于 metaspace 中 (non-heap)。</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_9.png class=image-loading-container data-pswp-width=1812 data-pswp-height=713 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_9.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1812 height=713 style=max-width:100%;height:auto></a></figure><p>注意：</p><ul><li>对于基本类型来说，<code>==</code>是进行数值比较</li><li>对于引用类型来说，<code>==</code>是进行<strong>地址值</strong>的比较</li></ul><p>常用 String 方法：</p><ul><li><code>public boolean equals(Object obj)</code>: 参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给 true;否则返回 false.<ul><li><code>equals</code>方法具有对称性，即<code>a.equals(b)和b.equals(a)</code>效果一样。</li><li>如果比较双方一个常量一个变量，推荐将常量字符串写在前面。推荐<code>"abc".equals(str)</code>, 不推荐<code>str.equals("abc");</code>(原因，如果变量为 null，比较后程序会报错。)</li></ul></li><li><code>public boolean equalsIgnoreCase(String str)</code></li><li><code>public int length()</code>: 字符串长度</li><li><code>public String concat(String str)</code>: 将当前字符串和参数字符串拼接</li><li><code>public char charAt(int index)</code>: 获取指定索引位置的单个字符。</li><li><code>public int indexOf(String str)</code>: 查找参数字符串在本字符串中首次出现的索引位置</li></ul><h4 id=静态-static-关键字>静态 static 关键字</h4><p>一旦用了 static 关键字，那么这样的内容就不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享一份数据。</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_10.png class=image-loading-container data-pswp-width=1731 data-pswp-height=733 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_10.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1731 height=733 style=max-width:100%;height:auto></a></figure><ol><li><p>static 修饰成员变量</p></li><li><p>static 修饰方法</p><p>一旦使用 static 修饰成员方法，这就成为了静态方法。静态方法不属于对象，而是属于类的。</p><ul><li>如果没有 static，那么必须首先创建对象，然后通过对象才能使用它。</li><li>对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。<code>类名称.静态方法</code></li><li>如果有 static 关键字，可以不创建对象，直接通过类名称调用它</li><li>对于本类当中的静态方法，可以省略类名称。</li></ul></li></ol><p>无论是成员变量还是成员方法，如果有 static 关键字修饰，都推荐用类名称进行调用</p><ul><li>静态变量：类名称。静态变量</li><li>静态方法：类名称。静态方法</li></ul><p>注意</p><ol><li><p><strong>静态不能访问非静态</strong>(重点)</p><p>原因：因为在内存当中是先有的静态内容，后有的非静态内容。（先人不知道后人，但是后人知道先人）</p></li><li><p>静态方法中不能用<code>this</code></p><p>原因：this 代表当前对象，但是静态方法是通过类调用的，和对象没有关系。</p></li></ol><p>static 内存图</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_11.png class=image-loading-container data-pswp-width=1821 data-pswp-height=720 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-10-Java-review-2-object-oriented-encapsulation/java_11.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1821 height=720 style=max-width:100%;height:auto></a></figure><p>注意：根据类名称访问静态成员变量时，全程和对象没有关系，只和类有关系。</p><h5 id=静态代码块>静态代码块</h5><ol><li><p>格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>类名称</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=c1>// 静态代码块内容</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。</p></li><li><p>静态内容优先于非静态，所以静态代码块优先于构造方法执行。</p></li><li><p>典型用途：用来一次性地对静态成员变量进行赋值。</p></li></ol><h4 id=arrays-类>Arrays 类</h4><p>两个常用的方法</p><ol><li><code>public static String toString(数组)</code>: 将参数数组变成字符串</li><li><code>public static void sort(数组)</code>: 按照默认升序对数组的元素进行排序。</li></ol><h4 id=math-类>Math 类</h4><p>常用方法</p><ol><li><code>public static double abs(double num)</code>: 获取绝对值</li><li><code>public statiic double ceil(double num)</code>: 向上取整</li><li><code>public static floor double floor(double num)</code>: 向下取整</li><li><code>public static long round(double num)</code>: 四舍五入</li></ol></main><footer><hr>&copy; <a href=https://ongoingblog.org/ target=_self>ONGOING-Z</a> 2020 -- 2026</footer></body></html>