<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Java 第二部分 封装 | ongoing's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Java 第二部分 封装</span></h1><h2 class=date>2020/10/10</h2></div><main><p>Java 基础知识第二部分。</p><h3 id=面向对象>面向对象</h3><ul><li>面向过程：强调步骤</li><li>面向对象：强调对象<ul><li>特征：封装、继承、多态</li></ul></li><li>类：一组相关属性和行为的集合。<ul><li>属性：状态信息</li><li>行为：可以做什么</li></ul></li><li>类和对象的关系<ul><li>类是对一类事物的描述，是<strong>抽象的</strong></li><li>对象是一类事物的实例，是<strong>具体的</strong></li><li>类是对象的模板，对象是类的实体。</li></ul></li></ul><h4 id=类的定义>类的定义</h4><ul><li>成员变量（属性）<ul><li>直接定义在类当中，<strong>在方法外边</strong>。</li></ul></li><li>成员方法（行为)<ul><li>无<code>static</code>关键字</li></ul></li></ul><p>一个类不能直接使用，需要根据类创建一个对象，才能使用。</p><p>步骤：</p><ol><li>导包：指出需要什么类，在什么位置。
<code>import 包名称.类名称</code>
对于和当前类属于同一个包的情况，可以省略导包语句。</li><li>创建：<code>类名称 对象名 = new 类名称();</code></li><li>使用<ol><li>使用成员变量：<code>对象名.成员变量名</code></li><li>使用成员方法：<code>对象名.成员方法名(参数)</code></li></ol></li></ol><p>一个对象的内存图
<img src=java_7.png alt></p><ul><li>方法的进栈和出栈</li><li>堆中<code>成员方法</code>保存的是一个地址值</li><li>方法要执行，一定要进栈，执行完毕就出栈</li><li>new 之后有默认值</li><li>对象的名称也叫做对象的引用名</li></ul><p>使用对象类型作为方法的参数：当一个对象作为方法的参数，传递到方法当中时，实际上传递进去的是对象的<strong>地址值</strong>。</p><p>使用对象作为方法的返回值：返回值其实就是对象的<strong>地址值</strong>。</p><p>成员变量与局部变量的区别：</p><ol><li>定义位置不一样（重要）<ul><li>成员变量：在方法外部，直接写在类中</li><li>局部变量：在方法内部</li></ul></li><li>作用范围不一样（重要）<ul><li>成员变量：整个类可以通用</li><li>局部变量：只有方法中可以使用，出了方法不能使用。</li></ul></li><li>默认值不一样<ul><li>成员变量：若没有赋值，会有默认值，规则和数组一样</li><li>局部变量：没有默认值，如果要想使用，必须手动进行赋值。</li></ul></li><li>内存位置不一样（了解）<ul><li>成员变量：位于堆内存</li><li>局部变量：位于栈内存</li></ul></li><li>生命周期不一样<ul><li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失。</li><li>局部变量：随着方法进栈而诞生，随着方法出栈而消失。</li></ul></li></ol><p>方法的参数也是局部变量，在调用的时候必然会被赋值。</p><h2 id=面向对象---封装性>面向对象 - 封装性</h2><ol><li><p><strong>封装在 java 中体现</strong></p><ul><li>方法是一种封装</li><li>关键字<code>private</code>也是一种封装
使用 private 将需要保护的成员变量进行修饰。在本类中可以随意访问，但是超出本类范围之外不能<strong>直接</strong>访问。
间接访问 private 成员变量：设置一对 getter/setter 方法<ul><li>setter 方法：有参数，无返回值。方法名称必须是<code>set</code>+首字母变大写 (setXxx)</li><li>getter 方法：无参数，有返回值。方法名称必须是<code>get</code>+首字母变大写 (getXxx)。</li><li>注意：对于基本数据类型中的<code>boolean</code>型，Getter 方法一定要写成<code>isXxx</code>形式，setXxx 规则不变。</li></ul></li></ul><p>封装：将一些细节信息隐藏起来，对于外界不可见。</p></li><li><p><code>this</code>关键字</p><p>作用：在重名下起到区分的效果。</p><p>当方法的局部变量和类的成员变量重名时，根据“就近原则”，优先使用局部变量。</p><p>如果需要访问本类中的成员变量，需要使用这种格式：<code>this.成员变量名</code></p><p><strong>通过谁调用的方法，谁就是 this.</strong></p></li><li><p>构造方法</p><p>专门用来创建对象的方法。（使用构造方法创造对象可以更具体）</p><p>格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>类名称</span> (参数) {
</span></span><span style=display:flex><span>    方法体
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意事项：</p><ul><li>构造方法名称必须和所在类名称完全一样</li><li>构造方法不需要写返回值类型，void 也不需要</li><li>构造方法不能产生返回值。</li><li>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数且方法体什么都不做。<code>public Student() {}</code></li><li>一旦编写了至少一个构造方法，那么编译器将不再赠送。</li><li>构造方法也是可以进行重载的。</li></ul><p>new 对象就是在调用构造方法。默认调用无参构造器，如果类中定义了带参数的构造器，则不会调用无参了。</p></li><li><p><strong>标准的类</strong>(Java Bean)</p><ul><li>所有成员变量都要使用 private 关键字修饰</li><li>为每一个成员变量编写一对 Getter/Setter 方法</li><li>编写一个无参数构造方法</li><li>编写一个全参数构造方法</li></ul><p>在 IDEA 中可以自动生成下面 3 项！！！菜单<code>Code -> Generate</code></p></li></ol><h3 id=api-文档的查看>API 文档的查看</h3><ol><li>包路径</li><li>构造方法</li><li>方法摘要</li></ol><h4 id=scanner-类>Scanner 类</h4><ul><li><p>引用类型一般使用步骤</p><ol><li>导包：<code>import 包路径.类名称;</code><ul><li>如果需要使用的目标类，和当前类位于同一个包下，则可以省略包不写。</li><li>只有<code>java.lang</code>包下的内容需要导包，其他的包需要 import 语句。</li></ul></li><li>创建： <code>类名称 对象名 = new 类名称();</code></li><li>使用：对象名。成员方法 ();</li></ol><p><code>System.in</code>代表从键盘输入。</p><p>其实键盘输入的都是字符串。</p></li></ul><h4 id=匿名对象>匿名对象</h4><p>正常的创建对象格式：<code>类名称 对象名 = new 类名称();</code></p><p>匿名对象创建格式：<code>new 类名称()</code></p><p>注意：匿名对象只能使用唯一的一次，下次只能创建新的匿名对象。</p><p>建议：如果确定有一个对象只需要使用一次，就可以使用匿名对象。</p><h4 id=random-类>Random 类</h4><p>生成随机数字。</p><h4 id=对象数组>对象数组</h4><p>数组可以存储任何数据类型</p><h4 id=arraylist-集合>ArrayList 集合</h4><p>其长度可以随意改变。</p><p>对于 ArrayList 来说，有一个尖括号<code>&lt;E></code>代表泛型。</p><p>泛型：装在集合中的所有元素，全都是统一的什么类型。</p><p>注意：<strong>泛型只能是引用类型</strong>，不能是基本类型。也就是说集合里面保存的都是地址，但是基本类型数据没有地址。</p><img src=java_8.png alt><img src=home/fifth/.config/Typora/typora-user-images/image-20201007182105425.png alt><p><code>ArrayList&lt;String> list = new ArrayList&lt;>();</code></p><p>注意右侧的尖括号也是要写的。</p><p>注意：对于 ArrayList 集合，直接打印得到的不是地址值，而是内容。如果内容为空，则得到的是空的中括号[].</p><p>常用方法：</p><ul><li>添加数据方法：<code>public boolean add(E e)</code></li><li>从集合中获取元素：<code>public E get(int index)</code></li><li>从集合中删除元素：<code>public E remove(int index)</code></li><li>获取集合长度：<code>public int size()</code></li></ul><h4 id=string>String</h4><ul><li>程序当中所有的双引号字符串，都是<code>String</code>类的对象（就算没有 new, 也照样是)</li></ul><p>字符串的特点 =</p><ol><li>字符串的内容永不可变。(重要)</li><li>因为字符串不可改变，所以字符串是可以共享使用的。</li><li>字符串效果上相当于是 char[]字符数组，但是底层原理是 byte[]字节数组。</li></ol><p>创建字符串的常见 3+1 种方式 =</p><ul><li>3 种构造方法</li><li><code>public String()</code>: 创建一个空白字符串</li><li><code>public String(char[] array)</code>: 根据字符数组内容创建字符串。</li><li><code>public String(byte[] array)</code>：根据字节数组的内容，创建对应字符串。</li><li>1 种直接创建：<code>String str = "Helo";</code></li></ul><p>字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。<strong>new</strong>的不在池中。</p><img src=java_9.png alt><p>注意：</p><ul><li>对于基本类型来说，<code>==</code>是进行数值比较</li><li>对于引用类型来说，<code>==</code>是进行<strong>地址值</strong>的比较</li></ul><p>常用 String 方法：</p><ul><li><code>public boolean equals(Object obj)</code>: 参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给 true;否则返回 false.<ul><li><code>equals</code>方法具有对称性，即<code>a.equals(b)和b.equals(a)</code>效果一样。</li><li>如果比较双方一个常量一个变量，推荐将常量字符串写在前面。推荐<code>"abc".equals(str)</code>, 不推荐<code>str.equals("abc");</code>(原因，如果变量为 null，比较后程序会报错。)</li></ul></li><li><code>public boolean equalsIgnoreCase(String str)</code></li><li><code>public int length()</code>: 字符串长度</li><li><code>public String concat(String str)</code>: 将当前字符串和参数字符串拼接</li><li><code>public char charAt(int index)</code>: 获取指定索引位置的单个字符。</li><li><code>public int indexOf(String str)</code>: 查找参数字符串在本字符串中首次出现的索引位置</li></ul><h4 id=静态-static-关键字>静态 static 关键字</h4><p>一旦用了 static 关键字，那么这样的内容就不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享一份数据。</p><img src=java_10.png alt><ol><li><p>static 修饰成员变量</p></li><li><p>static 修饰方法</p><p>一旦使用 static 修饰成员方法，这就成为了静态方法。静态方法不属于对象，而是属于类的。</p><ul><li>如果没有 static，那么必须首先创建对象，然后通过对象才能使用它。</li><li>对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。<code>类名称.静态方法</code></li><li>如果有 static 关键字，可以不创建对象，直接通过类名称调用它</li><li>对于本类当中的静态方法，可以省略类名称。</li></ul></li></ol><p>无论是成员变量还是成员方法，如果有 static 关键字修饰，都推荐用类名称进行调用</p><ul><li>静态变量：类名称。静态变量</li><li>静态方法：类名称。静态方法</li></ul><p>注意</p><ol><li><p><strong>静态不能访问非静态</strong>(重点)</p><p>原因：因为在内存当中是先有的静态内容，后有的非静态内容。（先人不知道后人，但是后人知道先人）</p></li><li><p>静态方法中不能用<code>this</code></p><p>原因：this 代表当前对象，但是静态方法是通过类调用的，和对象没有关系。</p></li></ol><p>static 内存图</p><img src=java_11.png alt><p>注意：根据类名称访问静态成员变量时，全程和对象没有关系，只和类有关系。</p><h5 id=静态代码块>静态代码块</h5><ol><li><p>格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>类名称</span> {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// 静态代码块内容</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。</p></li><li><p>静态内容优先于非静态，所以静态代码块优先于构造方法执行。</p></li><li><p>典型用途：用来一次性地对静态成员变量进行赋值。</p></li></ol><h4 id=arrays-类>Arrays 类</h4><p>两个常用的方法</p><ol><li><code>public static String toString(数组)</code>: 将参数数组变成字符串</li><li><code>public static void sort(数组)</code>: 按照默认升序对数组的元素进行排序。</li></ol><h4 id=math-类>Math 类</h4><p>常用方法</p><ol><li><code>public static double abs(double num)</code>: 获取绝对值</li><li><code>public statiic double ceil(double num)</code>: 向上取整</li><li><code>public static floor double floor(double num)</code>: 向下取整</li><li><code>public static long round(double num)</code>: 四舍五入</li></ol></main><script>document.addEventListener("DOMContentLoaded",function(){const e=new PhotoSwipeLightbox({gallery:".pswp-gallery",children:"a",pswpModule:PhotoSwipe});e.init()})</script>