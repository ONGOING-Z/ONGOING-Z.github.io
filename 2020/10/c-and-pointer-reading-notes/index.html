<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>《C and pointer》阅读笔记 | ongoing's blog</title><link rel=dns-prefetch href=https://image.ongoingblog.org><link rel=preconnect href=https://image.ongoingblog.org crossorigin><link rel=preload href=/css/style.css as=style><link rel=preload href=/css/fonts.css as=style><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/chroma.css><link rel=prefetch href=/js/katex/katex.min.css as=style><link rel=prefetch href=/js/katex/katex.min.js as=script><link rel=prefetch href=/css/loading.css as=style><script>function loadKaTeX(){const e=document.body?document.body.textContent:"",t=e.match(/\$\$|\\\[|\\\(|\$[^$\n]+\$/)||document.querySelector('script[type="math/tex"]');if(t){const e=document.createElement("link");e.rel="stylesheet",e.href="/js/katex/katex.min.css",e.onerror=function(){console.warn("KaTeX CSS 加载失败，尝试使用备用路径"),e.href="https://ongoingblog.org/js/katex/katex.min.css"},document.querySelector(`link[href="${e.href}"]`)||document.head.appendChild(e);const t=document.createElement("link");t.rel="stylesheet",t.href="/css/loading.css",t.onerror=function(){console.warn("loading.css 加载失败，尝试使用备用路径"),t.href="https://ongoingblog.org/css/loading.css"},document.querySelector(`link[href="${t.href}"]`)||document.head.appendChild(t);const n=document.createElement("script");n.src="/js/katex/katex.min.js",n.onerror=function(){console.warn("KaTeX JS 加载失败，尝试使用备用路径"),n.src="https://ongoingblog.org/js/katex/katex.min.js"},n.async=!0,n.onload=function(){const e=document.createElement("script");e.src="/js/katex/contrib/auto-render.min.js",e.async=!0,e.onload=function(){typeof renderMathInElement=="function"&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})},document.head.appendChild(e)},document.head.appendChild(n)}}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",function(){setTimeout(loadKaTeX,100)}):setTimeout(loadKaTeX,100)</script><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll("img.lazy-image[data-src]");function s(e){const t=e.getBoundingClientRect();return t.top>=0&&t.left>=0&&t.bottom<=(window.innerHeight||document.documentElement.clientHeight)+100&&t.right<=(window.innerWidth||document.documentElement.clientWidth)}function t(e){const t=e.getAttribute("data-src");if(t){const n=e.closest(".image-loading-container");return n&&n.classList.add("loading"),e.src=t,e.removeAttribute("data-src"),e.classList.remove("lazy-image"),e.addEventListener("load",function(){n&&n.classList.remove("loading")}),e.addEventListener("error",function(){n&&n.classList.remove("loading")}),!0}return!1}n.forEach(e=>{s(e)&&t(e)});const e=document.querySelectorAll("img.lazy-image[data-src]");if(e.length>0&&"IntersectionObserver"in window){const n=new IntersectionObserver((e,n)=>{e.forEach(e=>{if(e.isIntersecting){const s=e.target;t(s)&&n.unobserve(s)}})},{rootMargin:"100px"});e.forEach(e=>{n.observe(e)})}else e.length>0&&e.forEach(e=>{t(e)});document.querySelectorAll("main img").forEach(e=>{if(e.parentNode.tagName==="A"){e.parentNode.target="_blank";return}const t=document.createElement("a");t.href=e.src||e.getAttribute("data-src")||"",t.target="_blank",t.style.cursor="zoom-in",e.parentNode.insertBefore(t,e),t.appendChild(e)})})</script><link rel=prefetch href=/pagefind/pagefind-ui.css as=style><link rel=prefetch href=/pagefind/pagefind-ui.js as=script></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li><li><a href=/tags/>标签</a></li><li><a href=/#search onclick="return toggleSearch(),!1">搜索</a></li></ul><hr></nav><div id=search-container style=display:none><div id=search></div></div><script>let pagefindInitialized=!1,pagefindScriptLoaded=!1,pagefindCssLoaded=!1;function loadPagefind(){if(pagefindScriptLoaded)return;if(pagefindScriptLoaded=!0,!pagefindCssLoaded){const e=document.createElement("link");e.rel="stylesheet",e.href="/pagefind/pagefind-ui.css",e.onerror=function(){console.warn("Pagefind CSS 加载失败，尝试使用备用路径"),e.href="https://ongoingblog.org/pagefind/pagefind-ui.css"},document.head.appendChild(e),pagefindCssLoaded=!0}const e=document.createElement("script");e.src="/pagefind/pagefind-ui.js",e.async=!0,e.onload=function(){typeof PagefindUI!="undefined"&&initializePagefind()},e.onerror=function(){console.error("Pagefind JS 加载失败，尝试使用备用路径"),e.src="https://ongoingblog.org/pagefind/pagefind-ui.js"},document.head.appendChild(e)}function initializePagefind(){if(!pagefindInitialized)try{new PagefindUI({element:"#search",showSubResults:!0,showImages:!1}),pagefindInitialized=!0}catch(e){console.error("Pagefind 初始化失败:",e)}}function toggleSearch(){const e=document.getElementById("search-container");e.style.display==="none"||e.style.display===""?(e.style.display="block",pagefindScriptLoaded?!pagefindInitialized&&typeof PagefindUI!="undefined"&&initializePagefind():loadPagefind(),setTimeout(()=>{const t=e.querySelector("input");t&&t.focus()},100)):e.style.display="none"}</script><div class=article-meta><h1><span class=title>《C and pointer》阅读笔记</span></h1><h2 class=date>2020/10/01</h2></div><main data-pagefind-body><p>关于《C 和指针》这本书的读书记录。</p><h3 id=c-和指针>《C 和指针》</h3><h4 id=1th-快速上手>1th 快速上手</h4><ol><li><p>数组名</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span></code></pre></div><p>假设<code>int</code>型变量占 4 Byte，那么这个声明，编译器会给 c 预留内存空间 4×4 Byte，并且
数组名代表着指向数组第一个元素的指针。</p></li><li><p>字符串常量存储在常量区，常量区存储的内容是不能被修改的。</p></li><li><p>指针指定一个存储与计算机内存中的值的地址。</p></li><li><p>每个 C 程序必须有一个 main 函数，因为它是程序执行的起点。</p></li><li><p>在 C 语言中，数组参数是以<code>引用(reference)</code>形式进行传递的，即传址调用，
而标量和常量是按<code>值(value)</code>传递的。
在函数中对标量参数的任何修改都会在函数返回时丢失，因此，被调用函数无法修改
调用函数以传值形式传递给它的参数。
然而，当被调用函数修改数组参数的其中一个元素时，调用函数所传递的数组就会被实际地修改。</p></li><li><p>在 C 语言中，字符串是一串以<code>NUL</code>字节结尾的字符。<code>NUL</code>是作为字符串终止符，它本身并不被看作是字符串的一部分。字符串常量就是源程序中被<code>双引号</code>括起来的一串字符。例如，<code>"Hello"</code>在内存中占据 6 个字节的空间。</p></li><li><p>由于 scanf 函数的实现原理，所有标量参数的前面必须加上一个<code>&</code>符号。数组参数前面不需要加上<code>&</code>符号，但是若数组参数中出现下标引用，即实际参数是数组某个特定元素，那么它的前面也必须加上<code>&</code></p></li><li><p>编程提示</p><ul><li>在 while 和 if 表达式中蕴含赋值操作</li><li>始终要进行检查，确保数组不越界</li></ul></li></ol><h4 id=3th-数据>3th 数据</h4><ol><li><p>在 C 语言中，仅有 4 中基本数据类型 &ndash;
整型、浮点型、指针和聚合类型（如数组和结构等).</p></li><li><p>指针可以有效地实现如 tree 和 list 这类高级数据结构。</p></li><li><p>房子和它的门牌号码标识</p></li><li><p>可以把计算机内存想象成一条长街上的一间间房子，每间房子都用一个唯一的号码进行标识。每个位置包含一个值，这和它的地址是独立且显著不同的，即使它们都是数字。</p></li><li><p>程序在使用字符串常量会生成一个“指向字符的常量指针”。当一个字符串常量出现于一个表达式中时，表达式所使用的值就是这些字符所存储的地址，而不是这些字符本身。</p></li><li><p>不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身。</p></li><li><p>typedef 允许你为各种数据类型定义新名字。
<code>typedef int another_name</code></p><p>使用typedef声明类型可以减少使声明变得又臭又长的危险，尤其是那些复杂的声明。</p></li></ol><h4 id=4th-语句>4th 语句</h4><ol><li><p>空语句</p><p>C 最简单的语句就是空语句，它本身只包含一个分号。空语句本身并不执行任何任务，但有时还是有用。
适用场景 = 语法要求出现一条完整的语句。</p></li><li><p>括号是 if 语句的一部分。</p></li><li><p>C 并不具备布尔类型，零值表示假，非零值表示真。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;...&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>上边这条语句中，表达式<code>x > 3</code>的值将是 0 或 1.</p><h4 id=5th-操作符和表达式>5th 操作符和表达式</h4><ol><li>AND、OR、XOR 要求操作数为整数类型，它们对操作数对应的位进行指定操作，每次对左右操作数的各一位进行操作。</li><li>下标引用操作和间接访问表达式是等价的。
<code>array[下标] &lt;=> *(array + (下标))</code></li></ol><h4 id=6th-指针>6th 指针</h4><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/variable_addr.png class=image-loading-container data-pswp-width=1314 data-pswp-height=729 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/variable_addr.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1314 height=729 style=max-width:100%;height:auto></a></figure><p>Pointers - variables that store address of another variable.
指针变量存储的是地址</p><ol><li><p>间接访问 (de-referencing) 操作符</p></li><li><p>变量给了我们更方便的方法记住地址，但是硬件仍然通过地址访问内存位置。</p></li><li><p>变量的值就是分配给该变量的内存位置所存储的数值。??</p></li><li><p>指针变量可以作为左值，并不是因为它们是指针，而是因为它们是变量。对指针变量进行间接访问表示我们应该访问指针所指向的位置。</p><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/pointer_1.png class=image-loading-container data-pswp-width=209 data-pswp-height=64 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/pointer_1.png?format=webp&amp;quality=85" alt class=lazy-image width=209 height=64 style=max-width:100%;height:auto></a></figure><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/pointer_2.png class=image-loading-container data-pswp-width=1129 data-pswp-height=403 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/pointer_2.png?format=webp&amp;quality=85" alt class=lazy-image width=1129 height=403 style=max-width:100%;height:auto></a></figure><p><code>int *b = &amp;a</code>和<code>b = &amp;a</code>的区别是什么？
这两个表达的应该是一样的意思。
看第二个 b，这个 b 代表的是指针，如果加上声明语句的话和前一个是一样的
感觉<code>int * p; p = &amp;a;</code>,这个更好理解。</p><p>一个例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span> <span class=c1>// &amp;a is address of a
</span></span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span> <span class=c1>// p is 2002
</span></span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// p+1 is 2006
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>a pointer to pointer(pic source = youtube mycodeschool)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>**</span><span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>q</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>;</span>
</span></span></code></pre></div></li></ol><figure class=pswp-gallery style=display:inline-block;margin:0><a href=https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/pointer_to_pointer.png class=image-loading-container data-pswp-width=1581 data-pswp-height=636 target=_blank><img src=#ZgotmplZ data-src="https://image.ongoingblog.org/posts/2020-10-01-C-and-pointer-reading-notes/pointer_to_pointer.png?width=1200&amp;format=webp&amp;quality=85" alt class=lazy-image width=1581 height=636 style=max-width:100%;height:auto></a></figure></main><footer><hr>&copy; <a href=https://ongoingblog.org/ target=_self>ONGOING-Z</a> 2020 -- 2026</footer></body></html>