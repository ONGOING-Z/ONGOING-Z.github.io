<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lambda 表达式生成的类是 final 的 | ongoing's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>首页</a></li><li><a href=/categories/>分类</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>lambda 表达式生成的类是 final 的</span></h1><h2 class=date>2025/05/27</h2></div><main><h3 id=一背景>一、背景</h3><p>在看 aop 创建方法<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>时，代码中第三个判断条件</p><img src=third_condition.png alt><p><code>ClassUtils.isLambdaClass(targetClass)</code>说 lambda 表达式生成的类是 final，不能被继承，所以强制得用 JDK 动态代理。</p><p>这里用例子检查 lambda 生成的类是否是 final 的。</p><h3 id=二代码>二、代码</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LamdbaFinalDemo</span> {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>  Runnable lambda <span style=color:#f92672>=</span> () <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>  Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Runnable<span style=color:#f92672>&gt;</span> aClass <span style=color:#f92672>=</span> lambda.<span style=color:#a6e22e>getClass</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;====&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>boolean</span> isFinal <span style=color:#f92672>=</span> Modifier.<span style=color:#a6e22e>isFinal</span>(aClass.<span style=color:#a6e22e>getModifiers</span>());
</span></span><span style=display:flex><span>  System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;isFinal: &#34;</span> <span style=color:#f92672>+</span> isFinal);
</span></span><span style=display:flex><span>  System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(aClass.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结果</p><img src=result.png alt><h3 id=三为什么生成的类是-final-的>三、为什么生成的类是 final 的？</h3><p>为了确保 不可变性和安全性，JVM 会将生成的类标记为 final，防止其他代码继承或修改其行为。</p><h3 id=四在-spring-aop-中的判断>四、在 spring aop 中的判断</h3><p>由于 Lambda 类无法被继承，Spring AOP 只能对其使用 JDK 动态代理（而非 CGLIB）。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></main><script>document.addEventListener("DOMContentLoaded",function(){const e=new PhotoSwipeLightbox({gallery:".pswp-gallery",children:"a",pswpModule:PhotoSwipe});e.init()})</script>